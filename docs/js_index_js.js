"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkrust_webpack_template"] = self["webpackChunkrust_webpack_template"] || []).push([["js_index_js"],{

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create_game\": () => (/* binding */ create_game),\n/* harmony export */   \"dan_lerp\": () => (/* binding */ dan_lerp),\n/* harmony export */   \"export_level\": () => (/* binding */ export_level),\n/* harmony export */   \"fetch_json\": () => (/* binding */ fetch_json)\n/* harmony export */ });\n/* harmony import */ var _pkg_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pkg/index.js */ \"./pkg/index.js\");\n\r\n\r\n\r\n\r\nconst query_string = window.location.search;\r\nconst url_params = new URLSearchParams(query_string);\r\nvar level_name = url_params.get('level');\r\n\r\nconst debug = url_params.get('debug') == \"1\";\r\n\r\n//const URL_BASE = \"/\";\r\nconst URL_BASE = \"/temp_repo_for_hosting/\";\r\n\r\nconst canvas_width_pixels = 320;\r\nconst canvas_height_pixels = 500;\r\n\r\nconst progress = window.localStorage.getItem(\"progress\") ?? \"\";\r\nvar client = new _pkg_index_js__WEBPACK_IMPORTED_MODULE_0__.Client(debug, canvas_width_pixels, canvas_height_pixels, progress);\r\n\r\nvar redirecting = false;\r\n\r\nlet canvas = document.getElementById('canvas');\r\ncanvas.oncontextmenu = () => false;\r\nlet ctx = canvas.getContext('2d', { alpha: false });\r\nctx.imageSmoothingEnabled = false;\r\n\r\nconst canvasStyle = \r\n    \"image-rendering: -moz-crisp-edges;\" +\r\n    \"image-rendering: pixelated;\" +\r\n    \"image-rendering: -webkit-crisp-edges;\" +\r\n    \"image-rendering: crisp-edges;\";\r\n\r\ncanvas.style = canvasStyle;\r\n\r\nvar game = create_game(client, ctx, canvas);\r\n\r\nif (level_name) {\r\n    fetch_json(URL_BASE + 'levels/' + level_name + '.json')\r\n        .then(response => {\r\n            if (response.ok) {\r\n                return response.json();\r\n            }\r\n            else {\r\n                return fetch_json(URL_BASE + 'levels/empty.json').then(x => x.json());\r\n            }\r\n        })\r\n        .then(response => {\r\n            // @Cleanup round trip back to json\r\n            client.load_level(level_name, JSON.stringify(response));\r\n        });\r\n}\r\n\r\nconst sprites = [\r\n    {name: \"tree\", frame_count: 2},\r\n    {name: \"impact_particle\"},\r\n    {name: \"mine\"},\r\n    {name: \"flag\", frame_count: 2},\r\n\r\n    {name: \"font_small\", frame_count: 26},\r\n    {name: \"font_small_2\", frame_count: 26},\r\n    {name: \"font_small_black\", frame_count: 26},\r\n    {name: \"font_small_black_2\", frame_count: 26},\r\n\r\n    {name: \"font_blob\", frame_count: 26},\r\n    {name: \"font_blob_2\", frame_count: 26},\r\n    {name: \"font_blob_black\", frame_count: 26},\r\n    {name: \"font_blob_black_2\", frame_count: 26},\r\n\r\n    {name: \"font_linsenn_m5x7_medium_12\", font_def: true},\r\n\r\n    {name: \"pause_icon\"},\r\n\r\n    {name: \"trophy\"},\r\n];\r\n\r\nfor (let sprite_def of sprites) {\r\n    fetch(URL_BASE + 'sprites/spr_' + sprite_def.name + '.png')\r\n        .then(response => response.blob())\r\n        .then(blob => blob.arrayBuffer())\r\n        .then(arrayBuffer => {\r\n            if (sprite_def.font_def) {\r\n                fetch_json(URL_BASE + 'fonts/' + sprite_def.name + '.json').then(x => x.json()).then(x => {\r\n                    // @Cleanup\r\n                    let xx = JSON.stringify(x);\r\n                    client.load_font(sprite_def.name, new Uint8Array(arrayBuffer), xx);\r\n                });\r\n            }\r\n            else {\r\n                client.load_sprite(sprite_def.name, new Uint8Array(arrayBuffer), sprite_def.frame_count);\r\n            }\r\n        });\r\n}\r\n\r\nconst dialogue_files = [\r\n    \"menu\"\r\n];\r\n\r\nfor (let file of dialogue_files) {\r\n    fetch(URL_BASE + 'dialogue/' + file + '.adlib')\r\n        .then(response => response.text())\r\n        .then(content => {\r\n            client.load_dialogue_file(file, content);\r\n        });\r\n}\r\n\r\nlet prev_frame_time_ms = window.performance.now();\r\n\r\nvar left_down = false;\r\nvar right_down = false;\r\nvar up_down = false;\r\nvar down_down = false;\r\nvar w_down = false;\r\nvar a_down = false;\r\nvar s_down = false;\r\nvar d_down = false;\r\n\r\nvar shift_down = false;\r\nvar ctrl_down = false;\r\n\r\nvar r_down = false;\r\nvar z_down = false;\r\nvar x_down = false;\r\nvar c_down = false;\r\n\r\nwindow.addEventListener('keydown', (e) => {\r\n    if (e.keyCode == 37) {\r\n        left_down = true;\r\n    }\r\n    if (e.keyCode == 38) {\r\n        up_down = true;\r\n    }\r\n    if (e.keyCode == 39) {\r\n        right_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 40) {\r\n        down_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 87) {\r\n        w_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 65) {\r\n        a_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 83) {\r\n        s_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 68) {\r\n        d_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 16) {\r\n        shift_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 17) {\r\n        ctrl_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 82) {\r\n        r_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 90) {\r\n        z_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 88) {\r\n        x_down = true;\r\n    }\r\n\r\n    if (e.keyCode == 67) {\r\n        c_down = true;\r\n    }\r\n\r\n}, false);\r\nwindow.addEventListener('keyup', (e) => {\r\n    if (e.keyCode == 37) {\r\n        left_down = false;\r\n    }\r\n    if (e.keyCode == 38) {\r\n        up_down = false;\r\n    }\r\n    if (e.keyCode == 39) {\r\n        right_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 40) {\r\n        down_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 87) {\r\n        w_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 65) {\r\n        a_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 83) {\r\n        s_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 68) {\r\n        d_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 16) {\r\n        shift_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 17) {\r\n        ctrl_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 82) {\r\n        r_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 90) {\r\n        z_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 88) {\r\n        x_down = false;\r\n    }\r\n\r\n    if (e.keyCode == 67) {\r\n        c_down = false;\r\n    }\r\n\r\n}, false);\r\n\r\nvar canvas_mouse_x = 0;\r\nvar canvas_mouse_y = 0;\r\ncanvas.onmousemove = (e) => {\r\n    e.preventDefault();\r\n    canvas_mouse_x = e.offsetX;\r\n    canvas_mouse_y = e.offsetY;\r\n};\r\n\r\nvar canvas_mouse_wheel_delta = 0;\r\ncanvas.onwheel = (e) => {\r\n    e.preventDefault();\r\n    if (e.deltaY < 0) {\r\n        canvas_mouse_wheel_delta -= 1;\r\n    }\r\n\r\n    if (e.deltaY > 0) {\r\n        canvas_mouse_wheel_delta += 1;\r\n    }\r\n}\r\n\r\nvar left_mouse_down = false;\r\ndocument.body.onmousedown = function() { \r\n    left_mouse_down = true;\r\n}\r\ndocument.body.onmouseup = function() {\r\n    left_mouse_down = false;\r\n}\r\n\r\n// Touches logic adapted from https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\r\n\r\nvar ongoing_touches = [];\r\n\r\ncanvas.addEventListener(\"touchstart\", touch_handle_start);\r\ncanvas.addEventListener(\"touchend\", touch_handle_end);\r\ncanvas.addEventListener(\"touchcancel\", touch_handle_end);\r\ncanvas.addEventListener(\"touchmove\", touch_handle_move);\r\n\r\nfunction copy_touch({ identifier, pageX, pageY, offsetX, offsetY }) {\r\n    return { identifier, pageX, pageY, offsetX, offsetY };\r\n}\r\n\r\nfunction ongoing_touch_index_by_id(idToFind) {\r\n  for (let i = 0; i < ongoing_touches.length; i++) {\r\n    const id = ongoing_touches[i].identifier;\r\n\r\n    if (id === idToFind) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction touch_handle_start(e) {\r\n    e.preventDefault();\r\n\r\n    let touches = e.changedTouches;\r\n\r\n    for (let i = 0; i < touches.length; i++) {\r\n        ongoing_touches.push(copy_touch(touches[i]));\r\n    }\r\n}\r\n\r\nfunction touch_handle_end(e) {\r\n    e.preventDefault();\r\n    let touches = e.changedTouches;\r\n\r\n    for (let i = 0; i < touches.length; i++) {\r\n        let idx = ongoing_touch_index_by_id(touches[i].identifier);\r\n\r\n        if (idx >= 0) {\r\n            ongoing_touches.splice(idx, 1); // remove it; we're done\r\n        } else {\r\n            // Error\r\n            console.log(\"touch_handle_end error, could not find touch index.\");\r\n        }\r\n    }\r\n}\r\n\r\nfunction touch_handle_move(e) {\r\n    e.preventDefault();\r\n    let touches = e.changedTouches;\r\n\r\n    for (let i = 0; i < touches.length; i++) {\r\n        const idx = ongoing_touch_index_by_id(touches[i].identifier);\r\n\r\n        if (idx >= 0) {\r\n            ongoing_touches.splice(idx, 1, copy_touch(touches[i])); // swap in the new touch record\r\n        } else {\r\n            console.log(\"touch_handle_move error, could not find touch index.\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\nconst desired_fps = 60;\r\nconst ms_per_frame = 1000 / desired_fps;\r\n\r\nlet tick = () => {\r\n    window.requestAnimationFrame(tick);\r\n\r\n    const now_ms = window.performance.now();\r\n    const dt_ms = now_ms - prev_frame_time_ms;\r\n\r\n    if (dt_ms < ms_per_frame) {\r\n        return;\r\n    }\r\n\r\n    const excess_ms = dt_ms % ms_per_frame;\r\n    prev_frame_time_ms = now_ms - excess_ms;\r\n    \r\n    game.tick();\r\n    game.draw();\r\n}\r\n\r\ntick();\r\n\r\nfunction create_game(client, ctx, canvas) {\r\n    let game = {\r\n        client: client,\r\n        ctx: ctx,\r\n        canvas: canvas,\r\n        camera: create_camera(),\r\n\r\n        tick : function()\r\n        {\r\n            let input_json = JSON.stringify({\r\n                left_down: left_down,\r\n                right_down: right_down,\r\n                up_down: up_down,\r\n                down_down: down_down,\r\n                w_down: w_down,\r\n                a_down: a_down,\r\n                s_down: s_down,\r\n                d_down: d_down,\r\n                ctrl_down: ctrl_down,\r\n                shift_down: shift_down,\r\n                touches: ongoing_touches,\r\n                r_down: r_down,\r\n                z_down: z_down,\r\n                x_down: x_down,\r\n                c_down: c_down,\r\n            });\r\n\r\n            if (ongoing_touches.length > 0) {\r\n                //console.log(input_json);\r\n                //console.log(ongoing_touches);\r\n            }\r\n\r\n            this.client.set_inputs(input_json);\r\n\r\n            let mouse_json = JSON.stringify({\r\n                x: canvas_mouse_x,\r\n                y: canvas_mouse_y,\r\n                mouse_wheel_delta: canvas_mouse_wheel_delta,\r\n                left_down: left_mouse_down,\r\n                right_down: false,\r\n            });\r\n\r\n            // Reset mouse wheel status\r\n            canvas_mouse_wheel_delta = 0;\r\n\r\n            this.client.set_mouse_input(mouse_json);\r\n\r\n            let canvas_bounding = canvas.getBoundingClientRect();\r\n            this.client.set_canvas_bounding_rectangle(JSON.stringify({\r\n                x: canvas_bounding.x,\r\n                y: canvas_bounding.x,\r\n                width: canvas_bounding.width,\r\n                height: canvas_bounding.height,\r\n            }));\r\n\r\n            this.client.tick();\r\n            this.camera.tick();\r\n\r\n            const goto_level = this.client.should_goto_level();\r\n            if (goto_level) {\r\n                let new_progress = this.client.get_progress();\r\n                window.localStorage.setItem(\"progress\", new_progress);\r\n\r\n                if (!redirecting) {\r\n                    // Work around bug where if we set redirecting every frame\r\n                    // we interrupt a previous redirect and thus spin.\r\n                    redirecting = true;\r\n\r\n                    let new_url = URL_BASE + '?';\r\n\r\n                    if (goto_level != \"menu\") {\r\n                        new_url += '&level=' + goto_level;\r\n                    }\r\n\r\n                    if (debug) {\r\n                        new_url += '&debug=1'\r\n                    }\r\n\r\n                    window.location.href = new_url;\r\n                }\r\n            }\r\n        },\r\n\r\n        draw : function() {\r\n            this.ctx.fillStyle = \"black\";\r\n            this.ctx.fillRect(0, 0, canvas_width_pixels, canvas_height_pixels);\r\n\r\n            let image_data = this.ctx.createImageData(canvas_width_pixels, canvas_height_pixels);\r\n            this.client.draw(canvas_width_pixels, canvas_height_pixels, image_data.data);\r\n            this.ctx.putImageData(image_data, 0, 0);\r\n        }\r\n    }\r\n\r\n    return game;\r\n}\r\n\r\nfunction create_camera() {\r\n    let camera = {\r\n        target_x: 0,\r\n        target_y: 0,\r\n        target_scale: 1,\r\n\r\n        x: -100,\r\n        y: -100,\r\n        scale: 1,\r\n\r\n        tick: function() {\r\n            this.x = dan_lerp(this.x, this.target_x - 160, 8);\r\n            this.y = dan_lerp(this.y, this.target_y - 160, 8);\r\n            this.scale = dan_lerp(this.scale, this.target_scale, 8);\r\n        },\r\n    };\r\n\r\n    return camera;\r\n}\r\n\r\nfunction dan_lerp(x0, x, k) {\r\n    return (x0 * (k-1) + x) / k;\r\n}\r\n\r\nfunction export_level() {\r\n    console.log();\r\n}\r\n\r\nif (debug)  {\r\n    let container = document.getElementById(\"container\");\r\n    let button = document.createElement(\"button\");\r\n    button.innerText = \"Export Level\";\r\n    container.appendChild(button);\r\n    button.onclick = () => {\r\n        console.log(\"Click!\");\r\n        var level = client.export_level();\r\n        downloader_json(level, level_name + \".json\");\r\n    };\r\n}\r\nelse {\r\n    document.body.style.background = \"black\";\r\n\r\n    canvas.style.width = \"100%\";\r\n}\r\n\r\nfunction downloader_json(data, name) {\r\n\tlet blob = new Blob([data], {type: \"application/json\"});\r\n\tlet url = window.URL.createObjectURL(blob);\r\n\tdownload_uri(url, name);\r\n\twindow.URL.revokeObjectURL(url);\r\n}\r\n\r\nfunction download_uri(uri, name) {\r\n    let link = document.createElement(\"a\");\r\n    link.download = name;\r\n    link.href = uri;\r\n    link.click();\r\n}\r\n\r\nfunction fetch_json(url) {\r\n    return fetch(url, {\r\n        headers: { 'Accept': 'application/json' },\r\n    });\r\n}\n\n//# sourceURL=webpack://rust-webpack-template/./js/index.js?");

/***/ }),

/***/ "./pkg/index.js":
/*!**********************!*\
  !*** ./pkg/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Client\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   \"__wbg_error_f851667af71bcfc6\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_error_f851667af71bcfc6),\n/* harmony export */   \"__wbg_log_b103404cc5920657\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_log_b103404cc5920657),\n/* harmony export */   \"__wbg_new_abda76e883ba8a5f\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_abda76e883ba8a5f),\n/* harmony export */   \"__wbg_set_wasm\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   \"__wbg_stack_658279fe44541cf6\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_stack_658279fe44541cf6),\n/* harmony export */   \"__wbindgen_copy_to_typed_array\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_copy_to_typed_array),\n/* harmony export */   \"__wbindgen_object_drop_ref\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),\n/* harmony export */   \"__wbindgen_string_new\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_string_new),\n/* harmony export */   \"__wbindgen_throw\": () => (/* reexport safe */ _index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw)\n/* harmony export */ });\n/* harmony import */ var _index_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index_bg.wasm */ \"./pkg/index_bg.wasm\");\n/* harmony import */ var _index_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index_bg.js */ \"./pkg/index_bg.js\");\n\n\n\n(0,_index_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_index_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n//# sourceURL=webpack://rust-webpack-template/./pkg/index.js?");

/***/ }),

/***/ "./pkg/index_bg.js":
/*!*************************!*\
  !*** ./pkg/index_bg.js ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Client\": () => (/* binding */ Client),\n/* harmony export */   \"__wbg_error_f851667af71bcfc6\": () => (/* binding */ __wbg_error_f851667af71bcfc6),\n/* harmony export */   \"__wbg_log_b103404cc5920657\": () => (/* binding */ __wbg_log_b103404cc5920657),\n/* harmony export */   \"__wbg_new_abda76e883ba8a5f\": () => (/* binding */ __wbg_new_abda76e883ba8a5f),\n/* harmony export */   \"__wbg_set_wasm\": () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   \"__wbg_stack_658279fe44541cf6\": () => (/* binding */ __wbg_stack_658279fe44541cf6),\n/* harmony export */   \"__wbindgen_copy_to_typed_array\": () => (/* binding */ __wbindgen_copy_to_typed_array),\n/* harmony export */   \"__wbindgen_object_drop_ref\": () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   \"__wbindgen_string_new\": () => (/* binding */ __wbindgen_string_new),\n/* harmony export */   \"__wbindgen_throw\": () => (/* binding */ __wbindgen_throw)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    if (typeof(heap_next) !== 'number') throw new Error('corrupt heap');\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction _assertBoolean(n) {\n    if (typeof(n) !== 'boolean') {\n        throw new Error(`expected a boolean argument, found ${typeof(n)}`);\n    }\n}\n\nfunction _assertNum(n) {\n    if (typeof(n) !== 'number') throw new Error(`expected a number argument, found ${typeof(n)}`);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (typeof(arg) !== 'string') throw new Error(`expected a string argument, found ${typeof(arg)}`);\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n        if (ret.read !== arg.length) throw new Error('failed to pass whole string');\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction logError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        let error = (function () {\n            try {\n                return e instanceof Error ? `${e.message}\\n\\nStack:\\n${e.stack}` : e.toString();\n            } catch(_) {\n                return \"<failed to stringify thrown value>\";\n            }\n        }());\n        console.error(\"wasm-bindgen: imported JS function that was not marked as `catch` threw an error:\", error);\n        throw e;\n    }\n}\n\nconst ClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_client_free(ptr >>> 0, 1));\n/**\n*/\nclass Client {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_client_free(ptr, 0);\n    }\n    /**\n    * @param {boolean} debug\n    * @param {number} canvas_width_pixels\n    * @param {number} canvas_height_pixels\n    * @param {string} progress_json\n    */\n    constructor(debug, canvas_width_pixels, canvas_height_pixels, progress_json) {\n        _assertBoolean(debug);\n        _assertNum(canvas_width_pixels);\n        _assertNum(canvas_height_pixels);\n        const ptr0 = passStringToWasm0(progress_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.client_new(debug, canvas_width_pixels, canvas_height_pixels, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        ClientFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n    */\n    tick() {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        wasm.client_tick(this.__wbg_ptr);\n    }\n    /**\n    * @param {string} name\n    * @param {Uint8Array} png_data\n    * @param {string} font_def_str\n    */\n    load_font(name, png_data, font_def_str) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(png_data, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(font_def_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.client_load_font(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n    }\n    /**\n    * @param {string} name\n    * @param {Uint8Array} png_data\n    * @param {number | undefined} [frame_count]\n    */\n    load_sprite(name, png_data, frame_count) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray8ToWasm0(png_data, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        if (!isLikeNone(frame_count)) {\n            _assertNum(frame_count);\n        }\n        wasm.client_load_sprite(this.__wbg_ptr, ptr0, len0, ptr1, len1, !isLikeNone(frame_count), isLikeNone(frame_count) ? 0 : frame_count);\n    }\n    /**\n    * @param {string} name\n    * @param {string} content\n    */\n    load_dialogue_file(name, content) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.client_load_dialogue_file(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n    }\n    /**\n    * @param {string} inputs_json\n    */\n    set_inputs(inputs_json) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(inputs_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.client_set_inputs(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @param {string} inputs_json\n    */\n    set_mouse_input(inputs_json) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(inputs_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.client_set_mouse_input(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @returns {string}\n    */\n    should_goto_level() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.client_should_goto_level(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {string} json\n    */\n    set_canvas_bounding_rectangle(json) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.client_set_canvas_bounding_rectangle(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * @param {string} level_name\n    * @param {string} level_json\n    */\n    load_level(level_name, level_json) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        const ptr0 = passStringToWasm0(level_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(level_json, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.client_load_level(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n    }\n    /**\n    * @returns {string}\n    */\n    get_progress() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.client_get_progress(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {string}\n    */\n    export_level() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertNum(this.__wbg_ptr);\n            wasm.client_export_level(retptr, this.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {number} image_data_width\n    * @param {number} image_data_height\n    * @param {Uint8Array} image_data_bs\n    */\n    draw(image_data_width, image_data_height, image_data_bs) {\n        if (this.__wbg_ptr == 0) throw new Error('Attempt to use a moved value');\n        _assertNum(this.__wbg_ptr);\n        _assertNum(image_data_width);\n        _assertNum(image_data_height);\n        var ptr0 = passArray8ToWasm0(image_data_bs, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.client_draw(this.__wbg_ptr, image_data_width, image_data_height, ptr0, len0, addHeapObject(image_data_bs));\n    }\n}\n\nfunction __wbindgen_copy_to_typed_array(arg0, arg1, arg2) {\n    new Uint8Array(getObject(arg2).buffer, getObject(arg2).byteOffset, getObject(arg2).byteLength).set(getArrayU8FromWasm0(arg0, arg1));\n};\n\nfunction __wbg_error_f851667af71bcfc6() { return logError(function (arg0, arg1) {\n    let deferred0_0;\n    let deferred0_1;\n    try {\n        deferred0_0 = arg0;\n        deferred0_1 = arg1;\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n    }\n}, arguments) };\n\nfunction __wbg_new_abda76e883ba8a5f() { return logError(function () {\n    const ret = new Error();\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_stack_658279fe44541cf6() { return logError(function (arg0, arg1) {\n    const ret = getObject(arg1).stack;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n}, arguments) };\n\nfunction __wbg_log_b103404cc5920657() { return logError(function (arg0) {\n    console.log(getObject(arg0));\n}, arguments) };\n\nfunction __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack://rust-webpack-template/./pkg/index_bg.js?");

/***/ }),

/***/ "./pkg/index_bg.wasm":
/*!***************************!*\
  !*** ./pkg/index_bg.wasm ***!
  \***************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.id];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name) exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./index_bg.js */ \"./pkg/index_bg.js\");\n\n\n// exec wasm module\nwasmExports[\"\"]()\n\n//# sourceURL=webpack://rust-webpack-template/./pkg/index_bg.wasm?");

/***/ })

}]);